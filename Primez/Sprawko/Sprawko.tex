\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lscape} 
\usepackage{lmodern}
\usepackage[svgnames]{xcolor}
\usepackage[a4paper,bindingoffset=0.2in,%
            left=0.5in,right=0.5in,top=0.5in,bottom=1in,%
            footskip=.25in]{geometry}
\pagenumbering{gobble}
\usepackage[colorlinks=true, linkcolor=Black, urlcolor=Blue]{hyperref}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{color}
\usepackage[svgnames]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}


\begin{document}
\title{Sprawozdanie z zadania na Przetwarzanie Równoległe\\
\large Projekt 1\\
\large Sebastian Michoń 136770, Marcin Zatorski 136834}
\date{\vspace{-10ex}}
\maketitle

\section{Wstęp}
\begin {enumerate}
\item Sebastian Michoń 136770: grupa dziekańska L1 - grupa poniedziałkowa, 8:00
\item Marcin Zatorski 136834: grupa dziekańska L10 - grupa środowa, 13:30
\item Wymagany termin oddania sprawozdania: 27.04.2020r.
\item Rzeczywisty termin oddania sprawozdania: 27.04.2020r.
\item Wersja I sprawozdania
\item Adresy mailowe: sebastian.michon@student.put.poznan.pl, marcin.r.zatorski@student.put.poznan.pl
\item Celem realizowanego zadanie jest współbieżne wyznaczanie liczb pierwszych i badanie wydajności kodu w zależności od rozwiązania - domenowego i funkcyjnego.
\end {enumerate}

\section{Wykorzystywany system równoległy}
\begin {enumerate}
	\item Kompilator: icpc (Intel C++ compiler) 19.1.1.217
	\item Do zdobycia informacji na temat przetwarzania używałem Intel VTune'a
	\item System operacyjny: Ubuntu 18.04
	\item Procesor Intel(R) Core(TM) i7-4790K CPU @ 4.00GHz - 4 rdzenie, 2 wątki na 1 rdzeń: 8 procesorów logicznych i 4 fizyczne. Do pomiarów został wyłączony HyperThreading, co za tym idzie używałem co najwyżej 4 procesorów logicznych. Linia pamięci podręcznej procesora ma 64 bajty. Pamięc cache ma: 
	\begin{enumerate}
		\item L1: 256 kilobajtów
		\item L2: 1024 kilobajty
		\item L3: 8192 kilobajty
	\end{enumerate}
	Pamięc L2 i L3 jest dostępna dla wszystkich procesorów, L1 jest lokalna dla procesora.
	
\end {enumerate}

\section{Używane oznaczenia}
\begin{enumerate}
	\item \(l\), \(r\) oznaczają kolejno lewy i prawy koniec przedziału, w którym mają zostać wyznaczone liczby pierwsze.
	\item \textbf{Domknięta część sita} to taka część elementów zrównoleglonego sita, w której liczby oznaczono jako pierwsze/złożone i do której nie zostanie dokonany zapis w trakcie wykonywania sita. W szczególności, aby wypełnić równolegle sito o rozmiarze \(n\), jego część domknięta musi zawierać wszystkie liczby z przedziału \(<0;\lfloor\sqrt{n}\rfloor>\).
	\item \textbf{Otwarta część sita} to taka część elementów zrównoleglonego sita, w której liczby nadal mogą zostać odznaczone jako złożone.
	\item W kodach jeśli res[\(i\)]==1 to \(i\) jest liczbą złożoną.
\end{enumerate}

\section{Użyte kody}
\begin {enumerate}
	\item 01\_erasto\_single.cpp - Kod sekwencyjny, standardowe sito erastotenesa działające w\\ \(O(r*loglog(r))\), z podwójną optymalizacją: do odznaczania liczb używane są tylko liczby pierwsze (np. nie używam 6, aby odznaczyć 36, 42.. etc., ponieważ te zostały już odznaczone przez każdy pierwszy dzielnik 6 - czyli 2 i 3), ponadto odsiew rozpoczyna się od kwadratu danej liczby - jest to poprawne, ponieważ jeśli liczba \(x\) nie jest pierwsza to jej najniższy dzielnik \(d>1\) spełnia \(d\le \sqrt{x}\).
	\begin{lstlisting}[style=mystyle, caption= Sito Erastotenesa][language=C]
	for (i=2;i*i<=n;i++){
		if (res[i]==0){
			for (j=i*i;j<=n;j+=i) res[j]=1;
		}
	}
	\end{lstlisting}
	Celem kodu jest jedynie pokazanie koncepcji; nie zachodzi wyścig ani nie ma synchronizacji, ponieważ jest jeden wątek.
	\item 02\_most\_primitive.cpp - Kod sekwencyjny, który szuka dzielnika \(d\) liczby \(x\) pośród liczb mniejszych równych jej pierwiastkowi: \(d \le x\). Rozwiązanie to dizała w złożoności \(O((r-l)*\sqrt{r})\). Sprawdzałem podzielność także dla liczb, które nie są pierwsze, aby nie używać żadnych tablic poza tablicą znalezionych liczb pierwszych - celem jest pokazanie kodu wykorzystującego w jak najmniejszym stopniu tablice, co za tym idzie mającego niewielkie narzuty związane z dostępem do pamięci.
	\begin{lstlisting}[style=mystyle, caption= Rozwiązanie pierwiastkowe][language=C]
	for (i=2;i<=n;i++){
		for (j=2;j*j<=i;j++){
			if (i%j==0) {
				res[i]=1;
				break;
			}
		}
	}
	\end{lstlisting}
	\item 03\_erasto\_functional\_static\_schedule.cpp - kod równoległy, koncepcja sita, podejście funkcyjne. Funkcja najpierw wyznacza rekursywnie wszystkie liczby pierwsze \(p\le \sqrt{n}\), gdzie \(n\) to docelowy rozmiar sita, następnie sama poszukuje liczb pierwszych \(p\le n\). Kluczowa część algorytmu wygląda tak:
	\begin{lstlisting}[style=mystyle, caption= Sito funkcyjne ze static schedulingiem][language=C]
	#pragma omp parallel for
	for (i=0;i<=sq;i++){
		if (res[i]==1) continue;
		int sv=sq+1;
		int j=sv-sv%i+((sv%i==0)?0:i);
		for (j=min(i*i, j); j<=n; j+=i) res[j]=1;
	}
	\end{lstlisting}
	Gdzie \(sq\) oznacza \(\lfloor(\sqrt{n})\rfloor\), a \(sv\) to najmniejsza liczba większa równa \(sq+1\) i \(i^2\) podzielna przez \(i\). Własności tego kodu:
	\begin{enumerate}
		\item Dyrektywa powyżej tworzy zbiór wątków, którym przydziela w przybliżeniu równy podzbiór części domkniętej sita; co istotne, przy tak sformułowanym kodzie wątek będzie wykonywał kolejne iteracje - na przykład 1. wątek może wykonać je dla i=2, 3, 5, 7, a 2. wątek dla 11, 13, 17, 19. Jest to nieefektywne, ponieważ procesy dostaną taką samą ilość liczb, którymi będą odsiewać liczby z otwartej części sita, a proces, który dostanie najmniejsze liczby wykona najwięcej operacji: w powyższym przypadku, 1. wątek wykona nieco mniej niż \(\frac{n}{2}+\frac{n}{3}+\frac{n}{5}+\frac{n}{7}\) operacji oznaczenia liczby (gdzie \(n\) to rozmiar sita - "nieco mniej" wynika z tego, że nie odznaczam liczb \(x<\sqrt{n})\)), a 2. wątek \(\frac{n}{11}+\frac{n}{13}+\frac{n}{17}+\frac{n}{19}\) - czyli dużo mniej.
		\item Nie zachodzi wyścig (rozumiany jako zależność działania programu od kolejności wykonywania wątków), ponieważ wątki modyfikują tylko część tablicy, która nie jest używana do znajdowania liczb pierwszych, ponadto jeśli zmieniam wartość jakiegoś elementu tablicy, w której zaznaczam liczby pierwsze, to mogę tylko oznaczyć liczbę jako złożoną; co za tym idzie, jeśli liczba zostanie oznaczona przez kilka wątków jako liczba złożona, to niezależnie od tego, który z nich oznaczy ją jako pierwszy, który później nie zajdzie wyścig. Nie zmieniam w pętli żadnej zmiennej globalnej poza tablicą pierwszości.
		\item Synchronizacja zachodzi tylko na końcu pętli for, nie powinna mieć istotnego wpływu na czas obliczeń - wywołania rekursywne wykonają się relatywnie szybko, bo suma rozmiarów sit, które będą w nich wypełniane jest nie większa niż \(2*\sqrt{n}\) - można to pokazać przez \(\sqrt[2]{n}+\sqrt[4]{n}+..+k\le\sqrt{n}+\frac{\sqrt{n}}{2}+\frac{\sqrt{n}}{4}+..+\frac{\sqrt{n}}{2^{\lfloor log_2(n) \rfloor}}\le 2*\sqrt{n}\), gdzie \(k \le 4\) - warunek początkowy rekursji, zaś czas wykonania całego sita i tak jest ograniczony przez czas wykonania najwolniejszego procesu w pierwszym wywołaniu funcji (nierekursywnym).
		\item False sharing może zajść, gdy aktualizuję liczbę znajdującą się w cache po modyfikacji przez inny wątek. Taka sytuacja może zajść przez cały czas działania sita, ponieważ wszystkie wątki mogą aktualizować całą tablicę pierwszości; także w szczególnym przypadku, gdy sprawdzam pod kątem pierwszości liczbę \(x\) z części domkniętej sita, razem z nią ściągając do cache fragment części otwartej sita, ponieważ \(|x-\lfloor\sqrt{n}\rfloor|<64\) (64 bajty to rozmiar linii pamięci, a rozmiar typu bool to 1 bajt). Może on jednak zajść nie więcej niż \(64*log_2(n)\) razy, bo \(\sqrt[log_2(n)]{n}\le log_2(n)\).
	\end{enumerate}
	\item 04\_erasto\_functional\_handmade\_scheduling.cpp - kod równoległy, koncepcja sita, podejście funkcyjne. Kod jest analogiczny do poprzedniego, ale iteracje są ręcznie przypisywane do każdego wątku - Najpierw wyliczam sumę \(sum=\frac{1}{2}+\frac{1}{3}+\frac{1}{5}+\frac{1}{7}+...+\frac{1}{np}\), gdzie \(np\) to najwyższa liczba pierwsza \(np\le\sqrt{n}\)  i średnią liczbę operacji zmniejszoną \(n\)-krotnie, które mają być wykonywane przez proces: \(partsum=\frac{sum}{proc}\), gdize \(proc\) to liczba procesów. Następnie każdemu procesowi przydzielam w osobnej tablicy liczby pierwsze, którymi będzie skreślał elementy tablicy w ten sposób, że:
	\begin{enumerate}
		\item \(i\)-ty proces dostanie \(i\)-tą liczbę pierwszą
		\item następnie proces będzie dobierał sobie nieprzydzielone liczby pierwsze począwszy od \(np\) do momentu, w którym jego szacowana liczba operacji nie przekroczy \(psum\)
	\end{enumerate}
	Kod odpowiadający za przydział liczb pierwszych do tablicy procesu:
	\begin{lstlisting}[style=mystyle, caption=  Ręczny scheduling sita funkcyjnego][language=C]
	for (i=0;i<=sq;i++){
		if (res[i]==0) summa+=1.0/i;
	}
	part=summa/proc;
	
	int beg=0, end=sq;
	double partsum=0;
	for (i=0;i<proc;i++){
		ij[i]=0;
		partsum=0;
		for (j=beg;j<=end;j++){
			if (res[j]==0) {
				squarez[i][ij[i]]=j, partsum+=1.0/j, ij[i]++;
				break;
			}
		}
		beg=j+1;
		if (partsum<part){
			for (j=end;j>=beg;j--){
				if (res[j]==0) {
					squarez[i][ij[i]]=j, partsum+=1.0/j, ij[i]++;
				}
				if (partsum>=part) break;
			}
			end=j-1;
		}
	}
	\end{lstlisting}
	Dzięki powyższemu rozwiążę problem przedstawiony w części (a) poprzedniego rozwiązania - procesy będą względnie równo dzielić się pracą bez dodatkowego narzutu związanego z synchronizacją, przy czym procesy, które wezmą najniższe liczby pierwsze (2, 3, czasem 5) nadal wykonałyby największą pracę, ponieważ dla \(n<500000000 \land proc=8\) nadal zachodzi \(\frac{1}{2}\ge psum)\) - Analogicznie dla 3. Problemem z tą heurystyką jest nieuwzględnienie cache missów: odznaczanie liczb złożonych za pomocą liczby 2 będzie miało dużo rzadziej cache missa niż odznacznie liczb złożonych za pomocą za pomocą liczby 8387. Pozostałe części rozwiązania - (b), (c), (d) są identyczne dla tego kodu.
	\item 05\_erasto\_functional\_dynamic\_schedule.cpp - działa tak jak kod (3), ale używa innej dyrektywy:
	\begin{lstlisting}[style=mystyle, caption= Sito funkcyjne z dynamic schedulingiem][language=C]
	#pragma omp parallel for schedule(dynamic)
		for (i=0;i<=sq;i++){
			if (res[i]==1) continue;
			for (int j=i*i; j<=n; j+=i) res[j]=1;
		}
	\end{lstlisting}
	Dzięki zmianie dyrektywy na schedule(dynamic) wątek po zakończeniu swojej pracy wykonuje część (blok) pracy innego wątku zamiast niego - dzięki temu wątki będą się dzieliły równo pracą, natomiast w porównaniu z kodem (3) dojdzie narzut związany z koniecznością synchronizacji wątków. Rozwiązanie zadania (3) używało domyślnej klauzuli schedule(static).
	\item 07\_erasto\_domain.cpp - kod równoległy, koncepcja sita, podejście domenowe. Każdy wątek, znając swój numer, używając całej tablicy pierwszości do \(\sqrt{n}\) włącznie oznacza wszystkie liczby podzielne przez daną liczbę pierwszą większe niż \(\sqrt{n}\), które należą do przedziału unikalnego dla danego procesu, wyznaczonego za pomocą jego numeru.
	\begin{lstlisting}[style=mystyle, caption= Sito funkcyjne z dynamic schedulingiem][language=C]
	#pragma omp parallel
	{
		int left=(n/thr)*omp_get_thread_num(), i, j, based_left;
		int right=left+n/thr-1;
		if (omp_get_thread_num()==thr-1) right=n;
		if (left<=sq) left=sq+1;
		
		for (i=0;i<=sq;i++){
			if (res[i]==0){
				based_left=left-left%i+((left%i==0)?0:i);
				for (j=based_left;j<=right;j+=i) res[j]=1;
			}
		}
	}
	\end{lstlisting}
	Kod ten ma 3 zasadnicze różnice w porównaniu z kodem (3) w kontekście wspólbieżności:
	\begin{enumerate}
		\item Dyrektywa tworzy wątki, które podzielą się nieomal równomiernie pracą - ponieważ każdy wątek musi użyć każdej liczby pierwszej z części domkniętej sita do oznaczenia przedziału z części otwartej sita o wielkości (prawie) równej dla każdego wątku.
		\item False sharing zachodzi w szczególnym przypadku, gdy sprawdzam pod kątem pierwszości liczbę \(x\) - albo ją odnaczam jako złożoną, razem z nią ściągając do cache liczbę \(y\) w części otwartej używanej przez inny wątek, która może się zmieniać, ponieważ \(|x-y|<64\) (64 bajty to rozmiar linii pamięci, a rozmiar typu bool na systemie, na którym zaszło testowanie to 1 bajt). Może on jednak zajść nie więcej niż \((8+1)*64*log_2(n)\) razy, bo \(\sqrt[log_2(n)]{n}\le log_2(n)\), a liczba wątków to co najwyżej \(8\), dodatkowe \(+1\) wynika z wątku używającego podciągu obok tablicy z części domkniętej sita - jest to liczba o kilka rzędów wielkości mniejsza niż \(n\), zatem (co pokaże później VTune profiler) false sharing nie będzie istotnie wpływał na czas przetwarzania.
		\item Wątki będą modyfikowały współdzielone L2 i L3 cache - co za tym idzie, często będą zachodziły cache-missy, ponieważ L2 i L3 cache będą często zmieniały dane - w praktyce każdy wątek będzie modyfikował zupełnie inne części tablicy, które będą stale się zmieniać (inaczej niż np. w przypadku, w którym 1 wątek modyfikuje co 2. element tablicy).
	\end{enumerate}
	\item 08\_sqrt\_functional.cpp - kod równoległy, koncepcja dzielenia, podejście funkcyjne. Każdy wątek znając swój numer wyznacza 2 liczby: left i right, oznaczające przedział, z którego będę brał liczbę \(x\) i sprawdzał jej podzielność przez jakąkolwiek liczbę \(y\le\sqrt{x}\)
	\begin{lstlisting}[style=mystyle, caption= Sito funkcyjne z dynamic schedulingiem][language=C]
	int sq=floor(sqrt(n)), vv;
	vv=(sq-2)/thr;
	omp_set_num_threads(thr);
	#pragma omp parallel
	{
		int wisdom=omp_get_thread_num(), j, i;
		int v1=2+vv*wisdom, v2=2+vv*(wisdom+1)-1;
		if (wisdom==thr-1) v2=sq;
		
		for (i=2;i<=n;i++){
			for (j=v1;j*j<=i && j<=v2;j++){
				if (i%j==0) {
				res[i]=1;
				break;
			}
		}
	}
	\end{lstlisting}
	Własności tego kodu:
	\begin{enumerate}
		\item Wszystkie wątki dostaną względnie równy zbiór liczb pierwszych do sprawdzenia - to wynika ze sposobu wyznaczenia lewego i prawego końca przedziału
		\item W kodzie tym nie zachodzą wyścigi, bo wyznaczanie dzielnika w 1 wątku i ewentualne oznaczenie liczby jako złożona jest niezależne od działania innych wątków.
		\item Jedyna synchronizacja zajdzie na końcu pętli for.
		\item False sharing może zajść dla całej tablicy liczb pierwszych, ponieważ wątki ją modyfikują niezależnie od siebie.
	\end{enumerate}
	Fundamentalnym problemem algorytmu jest nonsensowny algorytm - każda liczba jest dzielona przez liczby do pierwiastka z niej niezależnie od tego, czy znalazłem jej dzielnik w innym wątku. To zapewnia mniejszy narzut związany z synchronizacją, jednocześnie generując problemy związane z nieefektywnością.
	
	\item 09\_sqrt\_domain.cpp - kod równoległy, koncepcja dzielenia, podejście domenowe. Każdy wątek używa liczb \(y\le\sqrt{n}\) do odznaczania własnego podzbioru \(N\) wyznaczanego przez dyrektywę \#pragma omp parallel for
	\begin{lstlisting}[style=mystyle, caption= Sito funkcyjne z dynamic schedulingiem][language=C]
	#pragma omp parallel for
	for (i=2;i<=n;i++){
		for (int j=2;j*j<=i;j++){
			if (i%j==0) {
				res[i]=1;
				break;
			}
		}
	}
	\end{lstlisting}
	Własności tego kodu:
	\begin{enumerate}
		\item Wszystkie wątki dostaną względnie równy podzbiór zbioru liczb do sprawdzenia o podobnym rozkładzie najniższych dzielników.
		\item W kodzie tym nie zachodzą wyścigi, ponieważ każdy wątek szuka dzielników innych liczb (i ewentualnie oznacza je jako pierwsze - jest to jedyna modyfikacja współdzielonej zmiennej przez wątek).
		\item Jedyna synchronizacja zajdzie na końcu pętli for.
		\item False sharing może zachodzić tylko na stykach podzbiorów zbioru otwartego modyfikowanych przez 2 wątki.
	\end{enumerate}
\end {enumerate}

\section {Wprowadzenie do rezultatów pomiarów}
\begin{enumerate}
	\item 
	\item VTune Profiler używa licznika zdarzeń sprzętowych do zdobycia informacji na temat przetwarzania, po czym (po przetwarzaniu) łączy te informacje w metryki np. CPI. Używa do zdobywania informacji PMU (performance monitoring unit) - ich liczba jest ograniczona, a sumują one informację o jednym, konkretnym zdarzeniu, przez co część zdarzeń jest raczej estymowana niż deterministycznie obliczana. Pojedynczy PMU wyliczający jakąś konkretną statystykę, wiedząc o zajściu zdarzenia inkrementuje rejestr; gdy rejestr przyjmie wartość progu próbkowania, jest on łączony z instrukcją tak, aby dowiedzieć się, po ilu zdarzeniach globalnych zaszło tyle zdarzeń danego typu (co istotne, aby statystyka/estymacja była zasadna, musi zajść odpowiednia liczba zdarzeń globalnych). Metryki, które zostały użyte w tym sprawozdaniu, to: 
	
	\begin{enumerate}
		\item Clockticks - Liczba cykli procesora w trakcie przetwarzania.
		\item Instructions retired - liczba przedziałów alokacji, które zostały aztwierdzone i w pełni wykonane.
		\item Retiring - procent przedziałów alokacji, które zostały użyte (nie zaszło ograniczenie front-endu ani back-endu) i wykonane (nie zaszła błędna spekulacja).
		
		\item Front-end bound - ile procent przedziałów alokacji nie zostało wykorzystanych przez ograniczenie części wejściowej procesora, albo inaczej: jak często back-end mógł przyjąć jakąś instrukcję, ale nie otrzymał jej od front-endu. Front-end odpowiada za przyniesienie instrukcji (fetch), zdekodowanie jej i przekazanie do back-endu.
		
		\item Back-end bound - ile procent przedziałów alokacji nie zostało wykorzystanych przez ograniczenie części wyjściowej procesora, albo incaczej: jak często back-end nie przyjmuje instrukcji od front-endu, ponieważ nie ma zasobów na ich przetworzenie. Składają się na to: Core Bound i Memory bound.
		\item Memory bound - ile procent przedziałów alokacji mogło nie zostać wykonane przez zapotrzebowanie na załadowanie albo składowanie instrukcji - czyli narzut związany z dostępem do pamięci, której albo nie ma w cache, albo jest zabrudzona.
		\item Core bound - ile procent przedziałów alokacji mogło nie zostać wykonane przez ograniczenia inne niż te związane z pamięcią - między innymi dzielenie czy operacje arytmetyczne na liczbach zmiennoprzecinkowych.
		\item Effective physical core utilization - ile procent fizycznych rdzeni średnio było używanych w trakcie przetwarzania.
		\item Metryki L1, L2, L3 bound, a także DRAM bound - procentowe dane, w ilu cyklach procesora zaszła sytuacja, w której program mimo posiadania odpowiednich danych w cache/DRAMie nie mógł przyjąć operacji.
	\end{enumerate}
	Wykorzystywanym trybem pracy było Microarchitecture Exploration.
\end{enumerate}

\section{Tablica wynków: kody od Pi2 do Pi6 w 3 wersjach}
\begin{flushleft}
\begin{landscape}
	\begin{tabular}{| l | l | l | l | l | l | l | l | l | l | l | l | l | l | l | l |}
		\hline
		name & LR & T & Elapsed & Ticks & IR & R & FEB & BEB & MB & CB & L1 & L2 & L3 & DRAMB & DTLBB \\ \hline
		03\_efss & 2 & 1 & 5.414 & 22824000000 & 5580000000 & 4.9 & 0.2 & 94.7 & 78.3 & 16.4 & 17.7 & 0.0 & 0.0 & 9.7 & 31.2 \\ \hline
		03\_efss & 2 & 2 & 5.269 & 26144000000 & 5584000000 & 5.7 & 0.2 & 93.8 & 76.0 & 17.9 & 15.1 & 1.8 & 11.8 & 0.0 & 36.6 \\ \hline
		03\_efss & 2 & 4 & 5.247 & 32372000000 & 5640000000 & 3.3 & 0.2 & 96.5 & 80.2 & 16.3 & 13.5 & 0.0 & 0.0 & 12.6 & 38.5 \\ \hline
		03\_efss & 2 & 8 & 5.031 & 35176000000 & 5612000000 & 3.1 & 0.3 & 96.6 & 79.9 & 16.7 & 17.0 & 0.3 & 0.0 & 10.6 & 42.7 \\ \hline
		03\_efss & 2 & 1 & 2.516 & 10668000000 & 2760000000 & 6.3 & 0.2 & 93.1 & 75.2 & 17.9 & 21.4 & 0.4 & 0.0 & 4.2 & 24.6 \\ \hline
		03\_efss & 2 & 2 & 2.438 & 12168000000 & 2760000000 & 5.3 & 0.3 & 94.3 & 77.8 & 16.4 & 22.4 & 0.2 & 0.0 & 4.9 & 25.2 \\ \hline
		03\_efss & 2 & 4 & 2.385 & 14944000000 & 2784000000 & 2.9 & 0.2 & 96.9 & 81.3 & 15.6 & 18.8 & 1.0 & 0.0 & 3.2 & 38.2 \\ \hline
		03\_efss & 2 & 8 & 2.386 & 16844000000 & 2808000000 & 10.6 & 0.6 & 88.8 & 70.1 & 18.8 & 35.9 & 0.0 & 0.0 & 10.8 & 81.6 \\ \hline
		03\_efss & 250000000 & 1 & 5.258 & 22300000000 & 5572000000 & 5.2 & 0.2 & 94.5 & 77.4 & 17.1 & 21.7 & 0.6 & 0.0 & 6.2 & 29.9 \\ \hline
		03\_efss & 250000000 & 2 & 5.165 & 25692000000 & 5584000000 & 5.8 & 0.2 & 93.7 & 76.5 & 17.2 & 18.1 & 0.5 & 0.0 & 8.9 & 35.0 \\ \hline
		03\_efss & 250000000 & 4 & 5.044 & 32128000000 & 5628000000 & 5.0 & 0.2 & 94.1 & 77.1 & 17.0 & 14.6 & 0.2 & 0.0 & 10.6 & 38.8 \\ \hline
		03\_efss & 250000000 & 8 & 5.027 & 37848000000 & 5616000000 & 2.7 & 0.4 & 96.8 & 79.7 & 17.1 & 5.4 & 0.0 & 0.0 & 22.6 & 45.8 \\ \hline
		04\_efhs & 2 & 1 & 10.012 & 42496000000 & 10624000000 & 5.4 & 0.2 & 94.3 & 77.7 & 16.6 & 18.8 & 0.0 & 0.0 & 9.4 & 28.5 \\ \hline
		04\_efhs & 2 & 2 & 9.617 & 55084000000 & 10792000000 & 3.8 & 0.2 & 95.7 & 78.1 & 17.6 & 6.9 & 0.2 & 0.0 & 21.2 & 36.2 \\ \hline
		04\_efhs & 2 & 4 & 8.146 & 96656000000 & 11224000000 & 2.5 & 0.3 & 96.9 & 79.1 & 17.8 & 13.5 & 0.0 & 14.5 & 0.0 & 37.1 \\ \hline
		04\_efhs & 2 & 8 & 8.418 & 129232000000 & 10904000000 & 1.6 & 0.7 & 97.5 & 79.8 & 17.7 & 0.0 & 1.0 & 3.6 & 23.9 & 38.8 \\ \hline
		04\_efhs & 2 & 1 & 4.688 & 19780000000 & 5240000000 & 6.1 & 0.3 & 93.0 & 76.1 & 16.8 & 20.1 & 0.0 & 0.0 & 7.0 & 26.2 \\ \hline
		04\_efhs & 2 & 2 & 4.323 & 25268000000 & 5324000000 & 6.2 & 0.3 & 93.2 & 75.5 & 17.7 & 14.6 & 0.0 & 0.0 & 13.2 & 34.2 \\ \hline
		04\_efhs & 2 & 4 & 3.914 & 47232000000 & 5520000000 & 3.8 & 0.4 & 95.4 & 77.5 & 17.9 & 11.6 & 1.2 & 0.0 & 13.2 & 33.1 \\ \hline
		04\_efhs & 2 & 8 & 3.733 & 55232000000 & 5416000000 & 2.2 & 0.4 & 97.4 & 78.9 & 18.5 & 14.6 & 0.3 & 0.0 & 12.4 & 35.0 \\ \hline
		04\_efhs & 250000000 & 1 & 10.032 & 42568000000 & 10624000000 & 5.3 & 0.3 & 94.3 & 78.1 & 16.1 & 18.3 & 0.0 & 9.8 & 0.0 & 28.3 \\ \hline
		04\_efhs & 250000000 & 2 & 9.703 & 55264000000 & 10788000000 & 3.9 & 0.3 & 95.6 & 78.4 & 17.3 & 4.8 & 0.2 & 23.1 & 0.0 & 36.4 \\ \hline
		04\_efhs & 250000000 & 4 & 8.097 & 96780000000 & 11200000000 & 2.7 & 0.4 & 96.9 & 79.6 & 17.2 & 15.7 & 0.1 & 0.0 & 13.4 & 38.5 \\ \hline
		04\_efhs & 250000000 & 8 & 8.392 & 131916000000 & 10904000000 & 2.0 & 0.6 & 97.3 & 79.4 & 17.9 & 0.0 & 0.8 & 0.0 & 28.3 & 39.2 \\ \hline
		05\_efds & 2 & 1 & 3.208 & 51560000000 & 6124000000 & 3.4 & 0.5 & 95.7 & 77.7 & 18.0 & 6.6 & 0.0 & 0.0 & 20.0 & 35.9 \\ \hline
		05\_efds & 2 & 2 & 3.267 & 52696000000 & 6080000000 & 3.3 & 0.5 & 95.7 & 77.6 & 18.1 & 6.3 & 0.0 & 0.0 & 21.0 & 42.2 \\ \hline
		05\_efds & 2 & 4 & 3.266 & 52584000000 & 6136000000 & 3.5 & 0.5 & 95.6 & 77.5 & 18.0 & 6.3 & 0.0 & 0.0 & 21.1 & 45.4 \\ \hline
		05\_efds & 2 & 8 & 3.599 & 57576000000 & 6120000000 & 3.1 & 0.5 & 95.9 & 77.7 & 18.2 & 10.4 & 0.0 & 17.3 & 0.0 & 39.8 \\ \hline
		05\_efds & 2 & 1 & 1.504 & 23936000000 & 3008000000 & 6.2 & 0.4 & 92.7 & 75.6 & 17.1 & 20.6 & 1.2 & 0.0 & 5.4 & 36.7 \\ \hline
		05\_efds & 2 & 2 & 1.689 & 26864000000 & 3008000000 & 5.0 & 0.3 & 93.7 & 75.3 & 18.4 & 21.7 & 0.5 & 0.0 & 3.1 & 23.4 \\ \hline
		05\_efds & 2 & 4 & 1.451 & 23396000000 & 2996000000 & 6.3 & 0.2 & 92.7 & 75.0 & 17.7 & 21.6 & 0.0 & 0.0 & 3.2 & 40.6 \\ \hline
		05\_efds & 2 & 8 & 1.499 & 24136000000 & 3008000000 & 6.4 & 0.5 & 92.4 & 72.7 & 19.7 & 22.7 & 0.3 & 0.0 & 7.1 & 38.5 \\ \hline
		05\_efds & 250000000 & 1 & 3.291 & 52884000000 & 6100000000 & 3.3 & 0.3 & 96.0 & 77.7 & 18.3 & 21.4 & 0.1 & 0.0 & 5.1 & 40.4 \\ \hline
		05\_efds & 250000000 & 2 & 3.768 & 60604000000 & 6128000000 & 3.4 & 0.4 & 96.0 & 77.8 & 18.3 & 13.6 & 2.7 & 0.0 & 10.8 & 33.3 \\ \hline
		05\_efds & 250000000 & 4 & 3.381 & 53600000000 & 6112000000 & 3.6 & 0.6 & 95.4 & 76.5 & 18.9 & 7.6 & 2.8 & 21.6 & 0.0 & 41.9 \\ \hline
		05\_efds & 250000000 & 8 & 3.254 & 52336000000 & 6100000000 & 3.4 & 0.5 & 95.9 & 77.8 & 18.1 & 8.6 & 0.0 & 0.0 & 19.3 & 39.8 \\ \hline
		09\_ed & 2 & 1 & 5.250 & 22300000000 & 5576000000 & 5.1 & 0.2 & 94.5 & 77.6 & 16.9 & 21.6 & 0.7 & 0.0 & 6.3 & 30.1 \\ \hline
		09\_ed & 2 & 2 & 4.451 & 37660000000 & 5596000000 & 4.0 & 0.1 & 95.7 & 78.4 & 17.3 & 22.1 & 0.3 & 0.0 & 4.5 & 28.3 \\ \hline
		09\_ed & 2 & 4 & 4.423 & 70124000000 & 5676000000 & 1.8 & 0.5 & 97.3 & 79.0 & 18.4 & 12.9 & 0.0 & 0.0 & 15.5 & 33.2 \\ \hline
		09\_ed & 2 & 8 & 4.394 & 70444000000 & 5704000000 & 2.2 & 0.5 & 97.0 & 78.7 & 18.4 & 17.0 & 0.0 & 10.2 & 0.0 & 31.5 \\ \hline
		09\_ed & 2 & 1 & 2.519 & 10668000000 & 2756000000 & 6.3 & 0.2 & 93.1 & 74.9 & 18.3 & 20.8 & 0.8 & 0.0 & 4.2 & 25.2 \\ \hline
		09\_ed & 2 & 2 & 2.143 & 18048000000 & 2764000000 & 5.7 & 0.2 & 93.5 & 74.4 & 19.1 & 24.9 & 0.1 & 0.0 & 4.2 & 27.6 \\ \hline
		09\_ed & 2 & 4 & 2.109 & 33596000000 & 2844000000 & 2.1 & 0.6 & 97.2 & 79.9 & 17.3 & 18.1 & 1.1 & 0.0 & 7.2 & 30.4 \\ \hline
		09\_ed & 2 & 8 & 2.084 & 32960000000 & 2792000000 & 1.9 & 0.3 & 97.6 & 80.3 & 17.3 & 18.0 & 0.0 & 0.0 & 7.1 & 30.4 \\ \hline
		09\_ed & 250000000 & 1 & 5.255 & 22324000000 & 5572000000 & 5.1 & 0.2 & 94.5 & 77.5 & 17.0 & 21.4 & 0.9 & 6.3 & 0.0 & 30.9 \\ \hline
		09\_ed & 250000000 & 2 & 4.546 & 38332000000 & 5596000000 & 4.0 & 0.3 & 95.4 & 77.9 & 17.6 & 17.1 & 0.0 & 0.0 & 9.9 & 33.6 \\ \hline
		09\_ed & 250000000 & 4 & 4.425 & 69876000000 & 5684000000 & 2.3 & 0.5 & 96.6 & 77.7 & 18.9 & 13.0 & 0.0 & 14.9 & 0.0 & 30.9 \\ \hline
		09\_ed & 250000000 & 8 & 4.397 & 69384000000 & 5636000000 & 2.9 & 0.5 & 96.2 & 78.0 & 18.2 & 18.3 & 0.2 & 0.0 & 10.0 & 30.4 \\ \hline
		08\_sf & 2 & 1 & 1.628 & 6680000000 & 7884000000 & 41.7 & 44.2 & 13.5 & 8.1 & 5.4 & 26.7 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		08\_sf & 2 & 2 & 4.555 & 24428000000 & 28976000000 & 44.3 & 44.8 & 10.6 & 6.3 & 4.2 & 28.0 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		08\_sf & 2 & 4 & 4.431 & 42516000000 & 50464000000 & 44.4 & 41.7 & 13.6 & 7.5 & 6.0 & 25.4 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		08\_sf & 2 & 8 & 3.505 & 55128000000 & 65368000000 & 43.8 & 43.1 & 12.5 & 7.2 & 5.3 & 26.6 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		08\_sf & 2 & 1 & 0.599 & 2520000000 & 2968000000 & 43.7 & 46.8 & 9.0 & 5.4 & 3.6 & 28.6 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		08\_sf & 2 & 2 & 1.615 & 8776000000 & 10380000000 & 40.4 & 35.6 & 22.9 & 10.9 & 12.0 & 21.5 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		08\_sf & 2 & 4 & 1.568 & 15144000000 & 17912000000 & 42.8 & 42.1 & 14.8 & 8.5 & 6.3 & 25.8 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		08\_sf & 2 & 8 & 1.376 & 19596000000 & 23196000000 & 44.9 & 39.1 & 15.2 & 8.0 & 7.2 & 23.8 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		08\_sf & 2500000 & 1 & 1.574 & 6672000000 & 7884000000 & 42.1 & 45.0 & 12.4 & 7.6 & 4.8 & 27.4 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		08\_sf & 2500000 & 2 & 4.554 & 24428000000 & 28972000000 & 44.2 & 43.5 & 12.1 & 7.0 & 5.0 & 27.0 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		08\_sf & 2500000 & 4 & 4.433 & 42536000000 & 50436000000 & 44.3 & 41.8 & 13.6 & 7.5 & 6.0 & 25.5 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		08\_sf & 2500000 & 8 & 3.636 & 55152000000 & 65380000000 & 44.3 & 45.4 & 9.9 & 5.9 & 4.0 & 27.7 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		09\_sd & 2 & 1 & 1.411 & 5984000000 & 6572000000 & 46.1 & 35.8 & 17.6 & 10.9 & 6.7 & 22.7 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		09\_sd & 2 & 2 & 0.882 & 5996000000 & 6572000000 & 46.8 & 32.2 & 20.6 & 13.0 & 7.6 & 23.3 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		09\_sd & 2 & 4 & 0.481 & 5996000000 & 6584000000 & 46.7 & 24.8 & 28.0 & 12.0 & 16.0 & 15.6 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		09\_sd & 2 & 8 & 0.394 & 5872000000 & 6460000000 & 39.6 & 36.0 & 23.9 & 15.0 & 8.9 & 23.2 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		09\_sd & 2 & 1 & 0.537 & 2260000000 & 2472000000 & 46.0 & 22.7 & 30.7 & 11.9 & 18.9 & 14.4 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		09\_sd & 2 & 2 & 0.338 & 2264000000 & 2480000000 & 35.2 & 18.0 & 46.4 & 18.6 & 27.8 & 11.6 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		09\_sd & 2 & 4 & 0.188 & 1624000000 & 1764000000 & 54.1 & 0.0 & 43.1 & 0.0 & 43.1 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		09\_sd & 2 & 8 & 0.154 & 1700000000 & 1856000000 & 64.8 & 0.0 & 35.1 & 0.0 & 35.1 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		09\_sd & 2500000 & 1 & 1.410 & 5988000000 & 6572000000 & 46.4 & 35.8 & 17.4 & 10.6 & 6.7 & 22.8 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		09\_sd & 2500000 & 2 & 0.884 & 5988000000 & 6576000000 & 46.4 & 36.8 & 16.3 & 10.2 & 6.1 & 23.7 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		09\_sd & 2500000 & 4 & 0.488 & 6000000000 & 6596000000 & 45.8 & 24.5 & 29.5 & 12.8 & 16.7 & 15.4 & 0.0 & 0.0 & 0.2 & 0.0 \\ \hline
		09\_sd & 2500000 & 8 & 0.403 & 5996000000 & 6572000000 & 39.0 & 30.2 & 29.9 & 17.1 & 12.8 & 21.2 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		02\_ss & 2 & 1 & 1.414 & 5992000000 & 6560000000 & 46.2 & 36.2 & 17.1 & 10.6 & 6.5 & 22.8 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		02\_ss & 2 & 1 & 0.538 & 2264000000 & 2468000000 & 46.4 & 22.9 & 30.1 & 12.2 & 17.9 & 14.4 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		02\_ss & 2500000 & 1 & 1.415 & 6000000000 & 6564000000 & 46.2 & 36.1 & 17.2 & 10.7 & 6.5 & 22.9 & 0.0 & 0.0 & 0.0 & 0.0 \\ \hline
		01\_es & 2 & 1 & 4.943 & 20984000000 & 5460000000 & 5.3 & 0.1 & 94.3 & 77.4 & 16.9 & 22.8 & 0.5 & 0.0 & 5.4 & 27.1 \\ \hline
		01\_es & 2 & 1 & 2.351 & 9944000000 & 2696000000 & 7.1 & 0.2 & 92.4 & 75.8 & 16.6 & 22.5 & 0.0 & 0.0 & 2.8 & 27.3 \\ \hline
		01\_es & 250000000 & 1 & 4.941 & 20956000000 & 5464000000 & 5.3 & 0.2 & 94.3 & 77.3 & 17.0 & 22.3 & 0.7 & 5.6 & 0.0 & 27.2 \\ \hline
	\end{tabular}
\end{landscape}
gdzie Czas użycia procesorów jest sumaryczny, a Przysp. to skrót od przyspieszenia kodu równoległego względem sekwencyjnego.
	
\end{flushleft}

\section{Wnioski}
\begin{enumerate}
	\item Rozwiązanie oparte na wyznaczaniu dzielników mniejszych równych od \(\sqrt{n}\) bardzo efektywnie się zrównolegla - procesy dzielą się pracą bardzo równo, przez większość czasu działania programu wykonuje się 7-8 wątków. Zwiększenie liczby procesów \(k\)-krotnie powoduje zmniejszenie czasu przetwarzania prawie \(k\)-krotnie, przy założeniu, że nowy wątek jest wykonywany przez inny procesor logiczny. Nie zachodzi prawie wcale False Sharing, ponieważ jedyna współdzielona zmienna to tablica liczb pierwszych. Wątki nie czytają współdzielonej pamięci, co powoduje, że praktycznie nie zachodzą cache missy. Wąskim gardłem rozwiązania jest Front-End Bound - co oznacza, że są większe problemy z dostarczeniem zadania do wykonania do Back-endu niż z jego wykonaniem; a także intensywne dzielenie, zwiększające Core-Bound. Algorytm pomimo zrównoleglenia nadal jest wolniejszy od sita, ponieważ ma większą złożoność - dla \(n=10^9\) ponad 1000-krotnie wolniejszy.
	\item Sito erastotenesa w podejściu funkcyjnym było w stanie uzyskać prawie 2-krotne przyspieszenie względem sekwencyjnego sita używając dynamic schedulingu. Co ciekawe, rozwiązania używające handmade schedulingu jest około 1.5 razy wolniejsze od rozwiązania używającego static schedulingu, pomimo tego, że ma prawie dwukrotnie wyższy współczynnik "effective physcial core utilization" - powodem jest to, że bardzo często zachodzi
	
	\item W podejściu 
\end{enumerate}

\end{document}
